% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/enclass.R
\name{enclass}
\alias{enclass}
\alias{ec_object}
\title{Create an encapsulated class}
\usage{
enclass(name, expr = NULL, package = .package())
}
\arguments{
\item{name}{An optional name for the class.  If passed an \code{ec_capsule} object, ignores \code{expr}.}

\item{expr}{An expression for assigning variables in new capsule.}

\item{package}{An optional package name for the class.}
}
\value{
A object with class \code{ec_object}
}
\description{
\code{ec_object}s are very flexible, and follow a simple set of rules:
\itemize{
\item \strong{properties} are accessed with \code{@}
\itemize{
\item \emph{active bindings} can be issues with \code{active()} to provide validators for setting and getting values
\item new \strong{properties} cannot be (easily) added to objects
}
\item \strong{methods} are accessed with \code{$}
\item \code{self} is a special \strong{property} that refers to the \code{ec_object} itself, an can be used inside \strong{methods} and \strong{properties} with \emph{active bindings}
\item \code{environment(ec_object)} is an \code{ec_capsule} environment
\item objects (i.e., \strong{properties} and \strong{methods}) are defined in the \code{expr} argument
\itemize{
\item all \strong{objects} assigned will be assigned to the \code{ClassObject}
\item \verb{self@<prop> <- value} and \verb{self$<method> <- function(...) \{\}} are equivalent to \verb{<prop> <- value} and \verb{<method> <- function(...) \{\}};
\item \strong{methods} do not need
}
\item objects defined with \code{.} names are considered \emph{private}
\itemize{
\item \emph{private} objects are still accessible
\item \emph{private} objects are hidden in tab completions
}
\item objects defined with \verb{.__*__.} names are considered \emph{reserved}
\itemize{
\item some reserved objects can be overridden (e.g., \code{.__new__.()}, \code{.__name__.})
\item \emph{reserved} objects are usually only accessed with \code{ec_object[[reserved]]}
\item all \emph{reserved} objects are directly stored within the \code{ec_capsule} environment
}
}
}
\section{Recommendations}{

\code{ec_object}s are meant to prioritize flexibility and ease of use over strict requirements.
The below are some opinions on best practices, but are not enforced:
\itemize{
\item avoid modifying \strong{properties} and \strong{methods} of a \code{ec_object} after it is created
\item avoid calling  \emph{private} objects from classes (especially if you're not the author)
\item use \code{self} and explicit namespace accessing (e.g., \code{pkg::name}) within \strong{methods} to avoid incorrect scoping
\item avoid using \verb{<<-} within \strong{methods}, use \code{self} instead, e.g., \code{self@prop <- value}
\item if you need temporary variables, wrap your expression in \code{local()} or be sure to use \code{rm()} to clean up afterwards
\item use \emph{private} objects for things you don't want/need users to call directly, or are only called within \strong{methods}
}
}

\examples{
Counter := enclass({
  .actions <- list()
  .track <- function(action, value) {
    self@.actions <- c(
      self@.actions,
      list(
        list(
          time = Sys.time(),
          action = action,
          value = value
        )
      )
    )
  }

  .show_actions <- function() {
    Reduce(rbind, lapply(self@.actions, as.data.frame))
  }

  current <- active(
    default = 0L,
    set = function(value) {
      value <- as.integer(value)
      stopifnot(value >= 0L)
      value
    }
  )

  add <- function(x = 1L) {
    x <- as.integer(x)
    self$.track("add", x)
    self@current <- self@current + x
    invisible(self)
  }

  show <- function() {
    cat("Current value:", self@current, "\n")
    invisible(self)
  }

  reset <- function(x = 0L) {
    stopifnot(x >= 0L)
    x <- as.integer(x)
    self$.track("reset", x)
    self@current <- x
    invisible(self)
  }
})

counter <- Counter()
counter@current
counter$add()
counter$show()
counter@current
counter$add(2)
counter$add(3L)
counter$show()
counter$reset()
counter$show()
try(counter$reset(-1L))
counter$show()
counter$.show_actions()
counter[[".__name__."]]
counter[[".__package__."]]
}
